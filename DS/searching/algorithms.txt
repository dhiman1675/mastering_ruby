########################################################################################
##### SEARCHING ALGORITHMS ###############################################################
########################################################################################
########################################################################################
1: Linear Search
________________________________________________________________________________________
=> Simplest algorithm: We iterate over the list, if we find the item, then we return its index;
   otherwise, -1 means item not found.

=> Time complexity:
      Best: O(1) = item is the first item in the array
      Worst: O(n)

########################################################################################
2. Binary Search
----------------------------------------------------------------------------------------
=> Binary search is faster than linear search, but it only works on a sorted list. If the
   list is not sorted, then first we need to sort it.

=> Then first we find the middle item like: middle = (left + right) / 2

               Ex: (0 + 9) / 2 = 4
=> After calculating the middle, we compare it with the element
   - we will return middle if item equal to middle
   - If the item is less than the middle, then we will do the same steps on the left
     partition
   - If the item is greater than the middle, we will do the same on the right partition

=> Binary Search is another example of divide and conquer algorithms

=> Time complexity: O(log n)
=> Space complexity: Recursive: O(log n), Iterative: O(1)

########################################################################################
3. Ternary Search
----------------------------------------------------------------------------------------
=> This is very similar to binary search but instead of dividing the list into 2 parts,
   we divide it into 3 parts

=> In this, we have 2 mid points: mid1 and mid2

=> To calculate the 2 middle points first we will calculate the partitionSize
      partitionSize = (right - left) / 3
      - mid1 = left + partitionSize
      - mid2 = right - partitionSize

=> Then, similar to binary search, compare the element with the mids. If not matched, then
    find the right partition and repeat the steps.

=> Time complexity: O((log base 3) n)

=> Binary search is faster than ternary search
########################################################################################
4. Jump Search
----------------------------------------------------------------------------------------
=> Its an improvement Linear search, but its not as fast as binary search

=>

########################################################################################
5. Exponential Search
----------------------------------------------------------------------------------------
